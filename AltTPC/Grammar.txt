
◆言語概要

	弱い静的型付け。勝手に型変換が行われる。特に、文字列が要求される際には自動的に文字列に変換される。
	TPCのメタ言語としての機能を強化することを念頭に置いており、自由なネストを作り出すことができる。
	基本的に、改行していても前の行の続きと見做す。@もしくはセミコロン(;)によって明示的に文の終わりを示すことができる。
	引数を並べる時などに使うコンマも特に必要はない（内部的には空白と同義）。

		@msg.show
			"a"
			"b";  // 自由な数の引数を取るので@もしくは;での文末の明示が必要

	関数（各基本型が持つ組み込み関数も含む）は、引数が0の時のみ()を省略して書くことができる。

		function number test() { return 1 }
		@v[1] = test;

	コメントは // で文末まで、もしくは/**/で範囲コメント。

	基本的には出力時は定数折り畳みを常に行う。


◆コマンド

	全て @ から始まる。ネストを作るコマンドは @end で閉じる。

		@if v[1] == func()
			@v[1] = 2
			@msg .show v[1] "\n"
				"abcdefgh"  // @msg.show "\v[1](改行)abcdefgh" 
			@pic[5].show 
				"filename"
				.pos(x, y)
		@end
 
	@をつけることで、メタ変数への代入かどうかを判別することができる（従来のメタ変数の扱いづらさの解消）。

		code qwe = v[1]
		code asd = v[2]
		qwe = asd  // これはv[1] = v[2] とはならず、qweにv[2]が代入されてしまう
		@qwe = 5  // v[2] = 5となる


	
◆型

	型名 名前　の形で定義する。

		number qwe = 4;
		string asd = "test" + qwe;  // test4
		code zxc = @{ v[1] };  // v[1] だけでもよい

	型名の前に接頭辞を付けることで以下の効果がある。順不同。
		
		const : 上書き不能。宣言と同時に値を代入しなければならない。
		static : 関数内・クラス内でのみ有効。そのスコープ内で値が維持される。

	型名宣言の後に{}で囲うと同じ接頭辞として連続で宣言できる。

		const number {
			qwe = 5
			asd  // 6。自動インクリメント
			zxc = qwe + 2  // 

		};

	$名前 とするとグローバル変数になる。そうでない場合は { } の内部のみのスコープとなる。
	別スコープの同名変数は今のスコープに近いものの方として解釈される。



	code

			コードブロック（{}）。 既定値はnull（0文字）。自由な文字列をコードとして扱う。
			展開された時に初めて内部のメタ変数も展開される。
			単独で配置されると展開し、+や=などの演算子の項になっているときは展開されない。

			code asd = { @v[1] = 5 } + { @msg.show "asd" };
			asd;

			.toStr : 文字列に変換する。定数折り畳みは行わない。
			.ext : 内部がv/s/t[]である場合、括弧を外して中身を出す。v[1 + 2].ext および @{ v[1 + 2] }.ext は 1 + 2。
    


 
v[], s[], t[]

			ツクール変数。内部には数値か、数値が入ったツクール変数か、数値が入った配列のどれかを持てるリテラル。
			修飾子 check を付与すると重複チェックをかけることができる（中身が数値もしくは数値が入った配列でない場合はエラーを出す）。

			v[] qwe = v[1]
			check v[] {
				var1 = v[2]
				var2 = v[11 .. 20]    // 範囲
				var3 = v[21, 22, 25]  // 複数
				var4 = v[16]  // var2との重複エラー
			}

			var2 = 1      // v[11 .. 20] = 1
			var2[1] = 2   // v[12] = 2
			var3 = 4      // v[21] = 4, v[22] = 4, v[25] = 4


			.ext : 中身を出す
				中身が単一の数値である場合は数値を、配列である場合は配列を返す。

				v[] a = v[1]
				v[] b = v[1 .. 5]
				v[] c = v[v[3]]
				
				// 以下は全てtrue
				if (a.ext is number)
				if (b.ext is array<number>)
				if (b.ext[1] is number)
				if (c is v[])
				if (c.ext is v[])
				if (c.ext.ext is number)


	temp

			temporary。システム側が自由に扱える一時変数。
			予約領域はtemp v/s/t[数値]、占有はtemp:v/s/t 名前 と宣言する。
			実体としては const code 名前 = v[番号]; であり、再代入不能な変数となる。
			関数の展開に使われるほか、手動で占有することもできる。解放宣言をするか、スコープを抜けると自動で解放される。
			領域が足りない時は警告が出る。また、tkv宣言と被っていた時は重複エラーが出る。
			配列で占有もできるが、必要な数の連続した領域がない場合はエラーが出る。
			
			temp {
				v[1 .. 100], v[201 .. 300], v[500]
				s[251 .. 400]
			};

			temp:v qwe, asd;
			temp:v zxc[10];
			qwe.free();


	string	

			文字列。既定値はnull（0文字）。ダブルクォートで囲まれた値。
			+演算子および+=演算子で結合することができる。
			ダブルクォートを挿入するにはエスケープが必要となる。
			他の型が与えられた場合、全て文字列に変換する。

			テンプレートリテラルが使用可能。定数文字列内で {} で囲った部分は展開される（つまり文字として扱う{}はエスケープ必須）。

			[a] : インデックスaの文字を返す。
			.eval : 文字列の中身をcode型として出力する。
			.length : 代入されている文字列の長さを返す。
			.toNum : 一文字目から見ていき、数値以外の文字が出現するまでの文字列をnumberに変換して返す。
			.substr(a, b) : 代入されている文字列のインデックスaからb文字を返す。
			.remove(a, b) : 代入されている文字列のインデックスaからb文字を削除した文字列を返す。
			.regex(a, b, c)	:	パターンaで検索した結果を返し、インデックスをnumber変数bに返す。
								マッチした時にc回まで無視する。b, cは省略可能。
			

			string asd = "te" + "st";  // test
			asd += "_";  // test_
			asd = asd + "test";  // test_test
			asd = "<< {asd} >>";  // << test_test >>


	number	

			数値。既定値は0。浮動小数点数も扱える。実体としては符号付き32bit整数/浮動小数点数。
			一度浮動小数を代入した場合はその後もずっと浮動小数のままであるため、
			整数に丸めたい場合は.floor()を再代入すると切り落とす。
			浮動小数点数は整数を要求された場合は自動で.floor()される。
			0xで16進数表記、0bで2進数表記もできる。

			.isFloat : 浮動小数点数かどうかを返す。
			.floor : 丸めた整数を返す。
			.to0x : 16進数表記の文字列を返す。
			.to0b : 2進数表記の文字列を返す。

			number a = 5;
			a++;  // 6
			a *= 3;  // 18
			a *= 1.1;  // 19.8
			if (a.isFloat) {
				@msg.show a.to0x;  // 0x419e6666
				a = a.floor;
				@msg.show a;  // 19
			}
			@msg.show (3.521).isFloat  // true。数値定数リテラルにはかっこを付けないと関数は使えない

	bool
			
			真偽値。false/trueの二種類で大文字小文字は無視。既定値はfalse。
			
			.toNumber : 偽が0、真が1の数値に変換する
			.toString : false/trueの文字列に変換する



	array<>	

			配列。array<string>のように配列にする型を指定して宣言する。
			サイズは決まっておらず、値が存在する一番最後のインデックスまでがそのまま長さになる。

			array<string> qwe = []
			array<number> asd = [1, 5, 9]
			@v[1] = asd[1]  // v[1] = 5

			numberのみ連番の値として a .. b ([a, a + 1, a + 2, .. b])という表記もできる。

			[a] : インデックスaの要素を返す。
			.clear() : 配列の中身を全て消す。
			.add(a...) : 末尾にaを追加する。複数可。
			.insert(a, b...) : aのインデックスに要素bを挿入する。複数可。
			.remove(a) : インデックスaを削除する。			
			.length : 配列の長さを返す。
			.last : 最後の要素を返す。


	dictionary<>

			連想配列。array<string, number>のように配列にする肩を指定して宣言する。

			dictionary<string, number> asd = [
				{ "test" : 1 }, { "test2" : 2 }
			];

			.clear()
			.add(a...)
			.insert(a, b...)
			.remove(a)
			.length
			.hasKey(a) : キーが存在するかどうかの真偽値を返す。



	暗黙の型変換

		互換性がある型の間で



◆関数

	function 戻り値の型 関数名(型, 名前, ...)の形で定義する。スコープの影響を受ける。
	returnがある場合、そこで実行を止めて結果を返す。
	return以前に書かれたコマンドコードは関数が書かれたネストの前に展開される。
	引数がない場合、()を省略して書くことができる（組み込み型の.lengthなどはそれである）。
	違う引数の同名関数を作ることも可能。

	function v[] asd(v[] a, v[] b) {
		@a = 1  // これらはこの関数が展開された@より前に置かれる
		@b = 2
		return someBool ? a : b
	}
	
	t[1] = asd(v[1], v[2]);  // v[1] = 1, v[2] = 2, t[1] .asg "true"/"false"



◆分岐

	if (条件式) {} else if (条件式) {} else {} の形。条件式はかっこで囲う必要がある。



◆クラス

	メンバ変数、メンバ関数を内部に持つクラスを生成可能。要は基本型以外に作れるユーザー定義型。

	class Slime {
		const number MaxHP = 30;
		const number ofs_HP = 1;
		code ID;

		new(code id) {
			ID = id;
		};

		function code HP() {
			return @{ v[ID + ofs_HP] };  // return v[ID + ofs_HP] でもよい
		};
		
		function code Percentage() {
			return @{ HP * 100 / MaxHP };
		};
	}

	Slime asd = new Slime( variableID );
	array<Slime> qwe = [new Slime(1), asd, new Slime(2)];  // 配列にもできる

	number zxc = asd.MaxHP;

	// 継承も可能

	class Slime -> LavaSlime {
		const number MaxHP = 50;  // 同名のメンバは隠蔽される

		function number baseMaxHP() {
			return base.MaxHP;  // Slime.MaxHP == 30;
		}
	}


◆繰り返し
  
  for (変数名, 最初, 最後) {}
  while (条件) {}
  foreach (配列の変数名, ループ変数名, インデックス変数名) {}



◆型チェック

  変数名 is (not) 型名 でtrueかfalseを返す。



◆メッセージ

	mes(a)でaをコンソールに出力する。



◆エラー

	err(a)でコンパイルを止めてコンソールにaを出力する。





