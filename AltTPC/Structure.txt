


@v[1] = 5

@
	=
		v[
			1
		]
		5




@v[1 .. 3, 5] = 6

@
	=
		v[
			..
				1
				3
			5
		]
		6

[]は直前が配列だった場合は添え字になり、配列でなかった場合には配列になる
v[1..3, 5]は添え字を付けられた場合は[v[1], v[2], v[3], v[5]]という解釈に変化する



@msg.show "a"
@msg.show "b"

@
	msg
		.
			show
				"
					a
				"
				

25.483.Floor().ToStr()

25
	.
		483
.
	Floor()
.
	ToStr()

(((25).483).Floor).ToStr

.
	.
		.
			25
			483
		Floor
	ToStr


{
	{ a } + { b }
}

{
	{
		a
	}
	
}







ピリオドは直前のノードのhasChildがfalseであっても強制的にtrueに書き換えてその子になる
childを持つ定数10進数が小数となる


includeしたとき、Nodeにincludeしたファイルのファイル名そのままを持たせるのではなく
Listにファイル名を追加し、そのインデックスを保存する


Nodeを生成したとき、そのNodeが受け取ることができる型を設定する
もしくは、Nodeが閉じる時にそのNodeが受け取れる型かどうかを見る
　- こちらの方がNodeに余計な情報を持たせる必要がない？
  - Nodeが閉じられるかどうかはInterpreterが判断する



BLOCKは{}のこと

CODE型は全ての子要素がVOIDを返さなければならない
STRING型の{}はSTRING_EXTとし、中身をSTRINGに変換してからNodeTypeがSTRINGに変化する


Nodeクラス
    - コンストラクタ(string) : ReadToken()を呼び出す
	- コンストラクタ() : ReadToken()を呼び出さず、空のNodeを作り出す
	- ReadToken() : キーワード解釈を行い（CODE/PENDING時のみ）、NodeTypeを振り分け、必要ならhasChildsをtrueにする
    - AddNodeToChild(string) : NodeをReadToken()を通して生成する　hasChildsがあるなら生成されたNodeを返し、そうでなければ親を返す（つまりネストの深さが維持される）
	- EndNode() : 現在のノードを終了し、そのノード内のノードが求められるNodeTypeであるかどうかを判別し、親を返す
	- GetParent() : EndNode()の機能縮小版　Interpreterにただ親を返すだけで判別はしない


Interpreterクラス
	- Run() :	現在のネストのNodeTypeに従いモードを切り替えながら構文解釈を行う
				






キーワード定義

"@msg" : [
	".show" : {
		"ID" : false,
		"arguments" : [
			"string", "number", "v[]", "s[]", "t[]", "v[v[]]", "s[s[]]", "t[t[]]"
		]
	}
]

"@pic" : [
	".show" : {
		"ID" : "true",
		"arguments" : [
			"peculiar" : {
				".pos" : [
					["number", "number"],
					["v[]", "v[]"],
					["v[v[]]", v[v[]]]
				]
			},
			""
		]
	}
]


